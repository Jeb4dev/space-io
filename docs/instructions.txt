# Space-IO — Engineering Instructions for the AI Coding Agent

## 0) Context & Goal

Build a jam-ready, **maintainable** browser .io game.

* **Client:** Phaser 3 + **TypeScript** (mobile-first).
* **Server:** Node.js + **TypeScript**, **Socket.IO**, authoritative fixed-tick sim.
* **Shared:** types, constants, and message schemas.
  Core loop: fly a ship, collect stardust/junk → **level up** → pick powerups (6 families × 5 tiers) → fight. **Alt-fire unlock at level 10**. **Gravity wells** (planets/suns/black holes) pull and can kill. **16 players / room**, bots optional.

---

## 1) Golden Rules

* **TypeScript everywhere**; `strict: true`. No `any` unless unavoidable; prefer precise types and zod-validated payloads.
* **Clean, simple code.** Small, cohesive modules; short functions; early returns; no deep inheritance.
* **Minimal comments.** Let code and clear names speak. Use TSDoc **only** for exported APIs or non-obvious algorithms.
* **Human style.** No AI signatures, no “generated by…”. Commit messages and code should look like a professional human wrote them.
* **Deterministic server.** No frame-rate coupling; fixed tick loop; avoid time-based randomness without seeds.
* **Ship it over perfect.** Prefer readable, boring solutions that the team can extend during the jam.

---

## 2) Repository Shape (monorepo)

Use **pnpm workspaces** with three packages:

```
space-io/
  packages/
    client/   # Phaser app
    server/   # Node + Socket.IO authoritative sim
    shared/   # zod schemas, enums, constants, math
```

* One `eslint` + `prettier` config at root; extend in packages.
* Scripts: `dev` (run client+server), `build`, `start` (server), `typecheck`, `lint`, `format`.
* Docker: server image + simple static hosting for client (or `vite preview`).

---

## 3) Coding Standards

* **Naming:** PascalCase for types/classes, camelCase for vars/functions, UPPER\_SNAKE for const enums.
* **Files:** one component/class per file; index re-exports at package boundaries only.
* **Imports:** absolute alias within package (`@client/...`, `@shared/...`). No relative chains like `../../..`.
* **Errors:** fail fast; explicit error types; never swallow exceptions. Log concise context (no stack spam).
* **Config:** env via `dotenv`; central `config.ts` with sane defaults and type-safe access.
* **Data shapes:** define once in `shared/messages.ts` with **zod**; validate on server ingress and before client use.

---

## 4) Networking Model (authoritative)

* **Tick:** server 30 Hz. Snapshots 10–15 Hz (configurable).
* **Client → server:** `ClientInput { seq, thrust[x,y], aim, fire, dtMs }` at 30–60 Hz (coalesced).
* **Server → client:** `ServerSnapshot` (nearby entities, pickups, wells, scoreboard) + event stream (level-up offers, kills).
* **Prediction:** client predicts own movement & firing; **reconcile** using last acked `seq`.
* **Interest management:** send full data within 2–3 screen radii; omit far entities.

---

## 5) Gameplay Systems (must-haves)

* **Progression:** XP from pickups & kills; `xpForLevel = base * level^1.4`.
* **Powerups (6 families × 5 tiers):** Hull(HP), Damage, Engine(Speed/Accel), FireRate, Magnet, Shield.
* **Alt-fire at Level 10:** choose **Railgun** or **Spread** (server-simulated).
* **Gravity wells:** planets/suns/black holes with `F = G*m/(d^2 + ε)`, clamp to `maxPull`, radius of influence. Heat/horizon damage cones.
* **Arena:** bounded world (config var). Camera locked to player; parallax starfield.
* **Death/respawn:** drop some XP orbs; respawn at edge; **2 s invuln**.
* **Scoreboard:** top-10 by score/XP; server emits diffs.
* **Names:** session name prompt, profanity filter.
* **Bots (simple):** wander/seek/flee; optional via config.

---

## 6) Client Guidelines (Phaser + TS)

* **Physics:** use Matter for client-side visuals/colliders; **server is source of truth**.
* **Scenes:** `Boot` (assets), `Game` (play), `UI` (HUD overlays) or UI as separate Layer/DOM.
* **Input:** desktop mouse aim + LMB fire; mobile: tap/drag to thrust & aim; on-screen buttons for fire/alt-fire.
* **Smoothing:** interpolate remote entities; cap warp distance; lerp HP bars; fade in spawns.
* **UI:** mobile-first sizing; HUD top-right scoreboard; bottom XP/level; modal with 3 choices on level up (pause inputs while open).
* **Assets:** load PNGs; expose an `assets.ts` manifest; name consistently (e.g., `ship_base`, `powerup_shield_t1`).
* **No heavy libs** beyond Phaser/socket client; keep bundle small.

---

## 7) Server Guidelines (Node + TS + Socket.IO)

* **Process model:** single process, one room (configurable later).
* **Fixed tick loop:** drift-corrected `setInterval` or frame scheduler.
* **Sim:** simple **circle-based physics** (pos, vel, radius, mass, hp).
* **Gravity:** compute once per well per entity; clamp close-range force; avoid tunneling with small sub-steps if needed.
* **Collisions:** circle vs circle for players, bullets, planets (planets can bounce or damage).
* **Combat:** server enforces ROF, bullet lifetime/speed, hit detection, damage.
* **Spawns:** seed celestial bodies; maintain pickup counts; respawn logic chooses safest edge zone.
* **State:** keep arrays/maps of entities; recycle IDs; avoid GC churn (object pools okay but not required).
* **Security:** validate all client messages with zod; throttle per-socket; ignore stale inputs.

---

## 8) Testing & Diagnostics

* **Type-only tests:** quick unit tests for math (gravity vector, XP curve, damage calc).
* **Manual playtests:** scripts to spawn bots and hot-reload client.
* **Logging:** single-line structured logs; include tick for sim events.
* **Dev HUD (toggle):** show ping, snapshot age, reconciles/sec.

---

## 9) Performance Budgets

* **Server:** ≤ 2 ms / tick at 16 players; avoid O(N²) where possible; spatial partition if needed.
* **Client:** 60 FPS target; particle count scales with device; avoid large textures; atlas sprites where possible.
* **Mobile:** touch input must be snappy; avoid layout thrash; DOM UI minimal.

---

## 10) Git & PR Hygiene

* **Branching:** `main` (protected). Feature branches `feat/<area>`, `fix/<area>`.
* **Conventional Commits:** `feat:`, `fix:`, `refactor:`, `chore:`, `docs:`, `perf:`.
* **PR size:** < 400 lines net where possible; include short checklist (builds, tested locally, lint passes).
* **Code review:** enforce TS types on new public APIs; reject hidden globals and magic numbers (move to `shared/constants.ts`).

---

## 11) Documentation (just enough)

* `README.md`: install/run, controls, config.
* `docs/DESIGN.md`: high-level architecture diagram + message flow.
* `docs/POWERUPS.md`: table of tiers, numbers, and visuals.
* `docs/CONTRIBUTING.md`: how to dev, PR rules, formatting.

---

## 12) Definition of Done (MVP)

* `pnpm i && pnpm dev` starts both apps; client connects to server.
* Player can move (mouse/touch) and primary fire; pickups grant XP; level-up modal with **3 choices** works.
* Gravity wells pull; hazards can kill; respawn with 2s invuln.
* Scoreboard shows live top-10.
* Alt-fire unlock choice at **Level 10** and functions.
* TypeScript strict; ESLint + Prettier pass.
* Docker image builds for server; optional compose for local stack.

---

## 13) Things to Avoid

* Over-engineering (DI containers, heavy ECS frameworks).
* Comment walls; prefer refactors and naming.
* Client authority on damage or physics.
* Unbounded asset sizes; keep PNGs optimized.

---

### Quick Task Order for the Agent

1. Scaffold monorepo (workspaces, lint/format, TS strict, shared package).
2. Implement `shared` types, constants, and zod schemas.
3. Implement server fixed-tick loop, entities, gravity, pickups, basic combat; Socket.IO endpoints.
4. Implement client boot + Game scene, inputs, prediction/reconciliation, starfield, HUD, scoreboard, level-up modal.
5. Hook up alt-fire gating at level 10.
6. Add bots (config off by default).
7. Polish: mobile HUD sizes, particles, hit flashes; Docker; README & docs.

Use this as your execution contract.
